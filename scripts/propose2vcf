#!/usr/bin/env python3
import argparse, collections, logging, sys
import numpy as np
import vcf

ORIGINAL_KEY="ORIGINAL"
VCF_FORMAT="GT:DM:OGT:ODM"

def make_arg_parser():
    """
    Returns an argument parser parser with the command line arguments
    """
    parser = argparse.ArgumentParser(
        description="Concatenate .tsv reports generated by svviz2 into a single .vcf file",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        "-i", "--input", type=str, help="Path to input vcf file", required=True
    )
    parser.add_argument(
        "-o",
        "--output",
        action="store",
        type=argparse.FileType("w"),
        default=sys.stdout,
        help="Output VCF file",
    )
    return parser

def main(args):
    vcf_reader = vcf.Reader(filename=args.input)
    # Add new format fields
    vcf_reader.formats["OGT"] = vcf.parser._Format(
        "OGT",
        "1",
        "String",
        "Genotype for the original variant",
    )
    vcf_reader.formats["ODM"] = vcf.parser._Format(
        "ODM",
        "G",
        "Float",
        "Original Mahalanobis distance for each genotype",
    )


    vcf_writer = vcf.Writer(args.output, vcf_reader)

    # TODO: Include data from original format
    AltCallData = collections.namedtuple('AltCallData', ['GT','DM','OGT','ODM'])

    original_records = {}
    alternate_records = {}

    for record in vcf_reader:
        if ORIGINAL_KEY not in record.INFO:
            assert record.ID not in original_records, "Duplicate original variants"
            original_records[record.ID] = record
        else:
            originals = record.INFO[ORIGINAL_KEY]
            for original in originals:
                if original in alternate_records:
                    alternate_records[original].append(record)
                else:
                    alternate_records[original] = [record]
    
    for id, record in original_records.items():
        if id not in alternate_records:
            vcf_writer.write_record(record)
        else:
            # Update record with new FORMAT
            record.FORMAT = VCF_FORMAT

            # Identify best alternate representation and genotype for each sample
            for i, call in enumerate(record.samples):
                min_dist = min(call.data.DM[1:])
                min_call = vcf.model._Call(record, call.sample, AltCallData(GT=call.data.GT, DM=call.data.DM, OGT=None, ODM=None))

                # Identify other representations to see if we want to overwrite the genotype
                for alternate_record in alternate_records[id]:
                    alternate_call = alternate_record.samples[i]
                    if not alternate_call.data.DM:
                        continue
                        
                    min_alt_dist_idx = np.argmin(alternate_call.data.DM)
                    min_alt_dist = alternate_call.data.DM[min_alt_dist_idx]
                    if min_alt_dist_idx != 0 and min_alt_dist < min_dist:
                        min_dist = min_alt_dist
                        min_call_data = AltCallData(GT=alternate_call.data.GT, DM=alternate_call.data.DM, OGT=call.data.GT, ODM=call.data.DM)
                        min_call = vcf.model._Call(record, call.sample, min_call_data)

            record.samples[i] = min_call
            vcf_writer.write_record(record)    




if __name__ == "__main__":
    parser = make_arg_parser()
    args = parser.parse_args()
    main(args)